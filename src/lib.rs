//! This library parses JSON generated by LDtk (Level Designers ToolKit) for use in Rust.
//! It is designed to be usable in any Rust program, including all game frameworks.
//!
//! See /examples directory for more.
//!

// mod definitions;
// pub mod ldtk_file;
// mod levels;

// pub use definitions::*;
// pub use ldtk_file::LdtkFile;
// pub use levels::*;
mod json_0_6_3;
use std::{fs::File, path::Path};

pub use json_0_6_3::*;

// this struct name has to match the auto-generated top-level struct.
// Currently mirroring the LDTK Haxe API as best I can figure out.
impl Project {

    pub fn new(f: String) -> Self {
        let mut o = Project::load_project(f);
        if o.external_levels {
            o.load_external_levels();
        }
        o
    }

    // Read in an LDTK project file
    pub fn load_project(f: String) -> Self {
        let json_file_path = Path::new(&f);
        let file = File::open(json_file_path).expect("project file not found");
        let o: Project = serde_json::from_reader(file).expect("error while reading");
        o
    }

    // Remove any items in the project.levels Vec ... useful when you
    // get external file info and want to replace the items with more
    // complete data extrated from the files.
    pub fn clear_levels(&mut self) {
        self.levels = Vec::new();
    }

    // Read in ALL the external level files referred to in an LDTK Project
    pub fn load_external_levels(&mut self) {
        // check to make sure there ARE separate levels
        // if not, then likely the call to this method
        // should do nothing because you already have
        // the levels.
        if self.external_levels {
            // get all the file names
            let mut all_level_files: Vec<String> = Vec::new();
            for level in self.levels.iter_mut() {
                let level_file_path = level.external_rel_path.as_ref().expect("missing level");
                all_level_files.push(level_file_path.to_string());
            }

            // get rid of existing levels (which don't have much data)
            self.clear_levels();

            // now add each of them to our struct
            // TODO: remove hard-coded file path
            for file in all_level_files.iter() {
                let mut full_path = "assets/".to_string();
                full_path.push_str(&file.to_string());
                let level_ldtk = Level::new(full_path);
                self.levels.push(level_ldtk);
            }
        }
    }

    pub fn get_level(&self, uid: i64) -> Option<&Level> {
        for level in self.levels.iter() {
            if level.uid == uid {
                return Some(level);
            }
        }
        None
    }
}

impl Level {
    // Read in a single external LDTK level file
    pub fn new(f: String) -> Self {
        let json_file_path = Path::new(&f);
        let file = File::open(json_file_path).expect("level file not found");
        let o: Level = serde_json::from_reader(file).expect("error while reading");
        o
    }
}

#[deprecated = "Use Project instead of LdtkJson to match LDtk documentation."]
pub struct LdtkJson;

// supports legacy name from 0.2.0 as well as
// some QuickType examples over at LDTK.
impl LdtkJson {
    pub fn new(f: String) -> Project {
        Project::new(f)
    }
}
